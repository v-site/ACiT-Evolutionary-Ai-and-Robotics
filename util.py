import numpy as np
import random
from operator import itemgetter
from timeit import default_timer as timer # Supposedly more better :))

def generate_initial_batch(batchSize, windowLength):

    parentGenomes = []

    for _ in range(batchSize):
        genome = random.randint(0, 2**(2**windowLength)-1) #must be less or equal to 2**(2**windowLength)-1 (for windowlength of 3, genome = (0,255))
        parentGenomes.append(format(genome, ('0' + str(2**windowLength) + 'b')))

    return parentGenomes



def set_condition_list(windowLength):
    conditionList = []

    for n in range(2**windowLength):
        # Appends n in binary format to list of conditions
        conditionList.append(format(n, ('0' + str(windowLength) + 'b')))

    return conditionList



def get_action(worldWidth, angel, windowLength, votingMethod, rules, iterations):

    worldMap = initialize_window(worldWidth, angel) #meh

    processedMap = apply_rules(worldMap,rules,windowLength,iterations) #slow

    action = voting(processedMap,votingMethod) #good enough

    return action



def initialize_window(worldWidth, angel):

    minAngle = -0.2095
    maxAngle =  0.2095
    worldMap = []

    # Maps the angle to a value between zero and the maximum binary worldwidth and converts to binary string
    binaryString = format(int(np.interp(angel, [minAngle, maxAngle], [0,2**worldWidth])), ('0' + str(worldWidth) + 'b'))

    for n in range(worldWidth):

        # Appends the each character in the binary string as an int to the worldMap array
        worldMap.append(int(binaryString[n]))

    return worldMap



def initialize_rules(windowLength,genome):

    responseList = []
    binaryString = genome

    if isinstance(genome, int):
        binaryString = format(genome, ('0' + str(2**windowLength) + 'b'))

    for n in range(2**windowLength):
        # WIP genome to be generated by evo
        responseList.append(int(binaryString[n]))

    # Merges the list of conditions with the list of responses
    return responseList



def apply_rules(worldMap,rules,windowLength,iterations):

    edgeWidth = int((windowLength-1)/2)
    tempMap = [0]*edgeWidth + worldMap + [0]*edgeWidth

    #t1=timer()

    for _ in range(iterations):

        processedMap = []
        n = edgeWidth

        for _ in range(len(worldMap)):

            processedMap.append(rules[''.join(map(str, tempMap[n-edgeWidth:n+edgeWidth+1]))])
            n += 1

        tempMap = [0]*edgeWidth + processedMap + [0]*edgeWidth

    #print(round((timer()-t1)*1000, 3))

    return processedMap



def voting(processedMap,votingMethod):

    if votingMethod == 'equal_split':

        l = int(len(processedMap)/2) #assumes the worldWith is even
        sumHead = sum(processedMap[0:l]) #TO-DO, check if this gives correct output,
        sumTail = sum(processedMap[l:])

        if sumHead == sumTail:
            return int(random.randint(0,1)) #randomly gives 0 or 1 of there is a tie
        if sumHead > sumTail:
            return 0

    return 1 # Unless if, return 1



def evolve(parents, cutSize, breedType):

    parents = list(map(itemgetter(0), parents))[int(len(parents)*(1-cutSize)):]

    Np = len(parents) #number of parents
    Lp = len(list(parents[0])) #length of genomes

    offspring = [] #initiate offspring list

    for i in range(Np):

        parentGenome = list(parents[i])

        for n in range(Lp):

            if  random.random() <= 0.1:

                if parentGenome[n] == '1':

                    parentGenome[n] = '0'
                else:
                    parentGenome[n] = '1'

        offspring.append(''.join(parentGenome))

    if breedType == 'one-point': #parent genome split in two and added together

        for i in range(int(Np/2)):

            p1 = list(parents[i])
            p2 = list(parents[-1-i])

            #All parents get two offsprings
            c1 = p1[:int(Lp/2)] + p2[int(Lp/2):] #creates the first offspring
            #c2 = p1[:int(Lp/2)] + p2[int(Lp)/2):] #creates the second offspring

            offspring.append(''.join(c1))
            #offspring.append(''.join(c2))

    if breedType == 'two-point': #parent genome split in three and added together

        for i in range(int(Np/2)):

            p1 = list(parents[i])
            p2 = list(parents[-1-i])

            #add variable to control the split
            c1 = p1[:int(Lp*0.25)]+p2[int(Lp*0.25):int(Lp*0.75)]+p1[int(Lp*0.75):]
            #c2 = p1[:int(Lp*0.25)]+p1[int(Lp*0.25):int(Lp*0.75)]+p2[int(Lp*0.75):]

            offspring.append(''.join(c1))
            #offspring.append(''.join(c2))

    if breedType == 'uniform': #parent genome split in three and added together

        for i in range(int(Np)):

            p1 = list(parents[random.randint(0, Np-1)])
            p2 = list(parents[random.randint(0, Np-1)])
            c = []

            for n in range(Lp):

                if  random.random() < 0.5:

                    c.append(p1[n])

                else:

                    c.append(p2[n])

            offspring.append(''.join(c))

    offspring += parents # Live to fight another day

    return offspring