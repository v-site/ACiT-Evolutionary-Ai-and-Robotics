import numpy as np
import random
from operator import itemgetter

def generate_initial_batch(batchSize, windowLength):

    parentGenomes = []

    for _ in range(batchSize):
        genome = random.randint(0, 2**(2**windowLength)-1) #must be less or equal to 2**(2**windowLength)-1 (for windowlength of 3, genome = (0,255))
        parentGenomes.append(format(genome, ('0' + str(2**windowLength) + 'b')))
  
    return parentGenomes



def get_action(worldWidth, angel, windowLength, votingMethod, rules, iterations):

    worldMap = initialize_window(worldWidth, angel)
    processedMap = apply_rules(worldMap,rules,windowLength,iterations)
    action = voting(processedMap,votingMethod)

    return action

def set_condition_list(windowLength):
    conditionList = []
    n = 0

    for n in range(2**windowLength):
        # Appends n in binary format to list of conditions
        conditionList.append(format(n, ('0' + str(windowLength) + 'b')))
        n += 1
    return conditionList

def initialize_rules(windowLength,genome):
    
    responseList = []
    binaryString = genome

    if isinstance(genome, int):
        binaryString = format(genome, ('0' + str(2**windowLength) + 'b'))

    n = 0

    for _ in range(2**windowLength):
        # WIP genome to be generated by evo
        responseList.append(int(binaryString[n]))
        n += 1

    # Merges the list of conditions with the list of responses
    return responseList



def initialize_window(worldWidth, angel):

    minAngle = -0.2095
    maxAngle =  0.2095
    worldMap = []
    n = 0

    # Maps the angle to a value between zero and the maximum binary worldwidth and converts to binary string
    binaryString = format(int(np.interp(angel, [minAngle, maxAngle], [0,2**worldWidth])), ('0' + str(worldWidth) + 'b'))

    for _ in range(worldWidth):

        # Appends the each character in the binary string as an int to the worldMap array
        worldMap.append(int(binaryString[n]))
        n += 1

    return worldMap



def apply_rules(worldMap,rules,windowLength,iterations):

    edgeWidth = int((windowLength-1)/2)
    tempMap = [0]*edgeWidth + worldMap + [0]*edgeWidth
    plotMap = worldMap

    for _ in range(iterations):

        processedMap = []
        n = edgeWidth

        for _ in range(len(worldMap)):

            processedMap.append(rules[''.join(map(str, tempMap[n-edgeWidth:n+edgeWidth+1]))])
            n += 1

        tempMap = [0]*edgeWidth + processedMap + [0]*edgeWidth
        plotMap = np.vstack((plotMap, processedMap))

    return processedMap



def voting(processedMap,votingMethod):

    if votingMethod == 'equal_split':

        l = int(len(processedMap)/2) #assumes the worldWith is even
        sumHead = sum(processedMap[0:l]) #TO-DO, check if this gives correct output,
        sumTail = sum(processedMap[l:])

        if sumHead == sumTail:
            return int(random.randint(0,1)) #randomly gives 0 or 1 of there is a tie
        if sumHead > sumTail:
            return 0

    return 1 # Unless if, return 1



def evolve(parents, cutSize, breedType, operator, crossoverRatio):

    #parents = np.array(parents)[-int(len(parents)*(cutSize)):]
    parents = list(map(itemgetter(0), parents))[int(len(parents)*(1-cutSize)):]
    #print('winners \n', parents, '\n')
    #print(parents)
    offspring = [] #initiate offspring list
    crossoverParents = []
    mutationParents = []

    if operator == 'deterministically':

        #crossoverParents = parents[:int((len(parents)*crossoverRatio))]
        #mutationParents = parents[(int(len(parents)*crossoverRatio)):]

        crossoverParents = parents
        mutationParents = parents

        #print('crosParent \n', crossoverParents, '\n')
        #print('mutParent \n', mutationParents, '\n')

    i = 0
    n = 0

    for i in range(len(mutationParents)):

        parentGenome = list(mutationParents[i])

        for n in range(len(parentGenome)):

            if  random.random() <= 0.01:

                if parentGenome[n] == '1':

                    parentGenome[n] = '0'
                else:
                    parentGenome[n] = '1'

            n += 1

        offspring.append(''.join(parentGenome))

        i += 1

    i = 0

    #if breedType == 'one-point-crossover': #parent genome split in two and added together

    for i in range(int(len(crossoverParents)/2)):

        p1 = list(crossoverParents[i])
        p2 = list(crossoverParents[i+1])

        #All parents get two offsprings
        c1 = p1[:int(len(p1)/2)] + p2[int(len(p2)/2):] #creates the first offspring
        c2 = p1[:int(len(p2)/2)] + p2[int(len(p1)/2):] #creates the second offspring
        offspring.append(''.join(c1))
        offspring.append(''.join(c2))

        i += 2

    i = 0

    #if breedType == 'two-point-crossover': #parent genome split in three and added together

    for i in range(int(len(crossoverParents)/2)):

        p1 = list(crossoverParents[i])
        p2 = list(crossoverParents[i+1])

        #add variable to control the split
        c1 = p1[:int(len(p1)*0.25)]+p2[int(len(p2)*0.25):int(len(p2)*0.75)]+p1[int(len(p1)*0.75):]
        c2 = p1[:int(len(p2)*0.25)]+p1[int(len(p1)*0.25):int(len(p1)*0.75)]+p2[int(len(p2)*0.75):]

        offspring.append(''.join(c1))
        offspring.append(''.join(c2))

        i += 2

    offspring += parents # Live to fight another day

    return offspring